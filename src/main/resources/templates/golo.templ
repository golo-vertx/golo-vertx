@comment{"Templating! The next row outputs all interfaces annotated with VertxGen-annotation."}

@code{

  def splitHelper(toSplit, splitter) {
    var array = [];
    var start = 0;
    for(int i = 0; i<toSplit.length(); i++) {
        if(toSplit.substring(i, i+1).equals(splitter)) {
            array.add(toSplit.substring(start, i));
            start = i + 1;
        }
    }
    array.add(toSplit.substring(start, toSplit.length()));
    return array;
  }

  def parseGenericNames(genCount, str) {
    var generics = "";
    var identifier = "name=";
    var startIndex = 0;
    for(int i = 0; i<genCount; i++) {
         startIndex = str.indexOf(identifier);
         generics = generics + str.substring(startIndex+identifier.length(),startIndex+identifier.length()+1);
         str = str.substring(startIndex+identifier.length()+1, str.length());
         if(i + 1 < genCount) {
            generics = generics + ",";
         }
     }
    return generics;
  }

  def takeRestOfStr(str, start) {
    var startIndex = str.indexOf(start);
    return str.substring(startIndex, str.length());
  }

  def countGenerics(method) {
    var count = 0;
    for(int i = 0; i<method.toString().length() -12 ; i++) {
            if(method.toString().substring(i, i+13).equals("TypeParamInfo")) {
                count = count + 1;
            }
        }
    return count;
  }

  def typeCheck(method) {
     var str = method.toString();
     var generics = "";
     var genCount = countGenerics(method);
     var indexOfMethodName = genCount;
     var elementsInMethodDefinition = splitHelper(method.toString(), " ");
     if(genCount == 0) {
        return str;
     }
     generics = parseGenericNames(genCount, method.toString());
     str =  "<"+generics+"> ";
     if(elementsInMethodDefinition[indexOfMethodName] == "void" ||
        generics.contains(elementsInMethodDefinition[indexOfMethodName]) ||
        elementsInMethodDefinition[indexOfMethodName].contains("(") == false) {
        str = str + elementsInMethodDefinition[indexOfMethodName] + " ";
        indexOfMethodName = indexOfMethodName + 1;
     }
     return str + takeRestOfStr(method.toString(), elementsInMethodDefinition[indexOfMethodName]);
  }

  def genGoloModuleName(type) {
    return type.raw.translatePackageName("golo");
  }

   def className(type) {
        var absName = type.toString();
        var split = splitHelper(absName, ".");
        return split[split.size() - 1];
   }

   def constructorMethod(className, type, method) {
        var delegateCall = type.raw + "." + injectParamsToMethodCall(method);
        var currentClass = genGoloModuleName(type.raw) + "." + className + ".class";
        var indexOfClassName = countGenerics(method);
        var castObjectTo = splitHelper(method.toString(), " ")[indexOfClassName];
        var call = "return (" + castObjectTo + ")InternalHelper.safeCreate("+delegateCall+", "+ currentClass+")";
        return call;
   }

   def injectParamsToMethodCall(method) {
        var call = "";
        call = method.name + "(";
        var params = method.params;
        var p;
        for(int i = 0; i < params.size(); i++) {
            p = splitHelper(params.get(i).name, " ");
            call = call + p[0];
            if(i < params.size() - 1) {
                call = call + ", ";
            }
        }
        return call + ")";
   }

   def isConstructorMethod(type, method) {
        if(method.staticMethod) {
            var cp = splitHelper(method.toString(), " ");
            var classIndex = countGenerics(method);
            var class = cp[classIndex];
            if(class.equals(type.toString())) {
                return true;
            }
        }
        return false;
   }

   def callForOriginalAPI(className, type, method) {
        if(isConstructorMethod(type, method)) {
            return constructorMethod(className, type, method);
        }
        var call;
        var returnTypes = splitHelper(method.toString(), " ");
        if(returnTypes[0].equals("void") || returnTypes[1].equals("void") ||
            (returnTypes.size() > 2 && returnTypes[2].equals("void"))) {
            call = "";
        } else {
            call = "return (" + method.returnType + ")";
        }
        if(method.staticMethod) {
            call = call + type.raw.toString() + ".";
        } else {
            call = call + "delegate.";
        }
        call = call + injectParamsToMethodCall(method);
        return call;
   }

   def createMethodDefinition(type, method) {
        var ret = "";
        if(method.staticMethod) {
            ret = "static ";
        }
        return ret + typeCheck(method);
   }

   def findUniqueFunctionName(functionNames, method) {
        if(method.params == empty) {
            functionNames.add(method.name);
            return method.name;
        }
        var nameIsFree = true;
        var currentName = "";
        for(int y=0; y < functionNames.size(); y++) {
            currentName = functionNames.get(y);
            if(currentName == method.name) {
                nameIsFree = false;
            }
        }
        if(nameIsFree) {
            functionNames.add(method.name);
            return method.name;
        }
        var name = method.name + "By";
        var mini = "";
        for (int i =0; i < method.params.size(); i++) {
           mini = method.params.get(i).name;
           name += mini.substring(0,1).toUpperCase() + mini.substring(1,mini.length());
           if(i != method.params.size() -1) {
                name += "And";
           }
        }
        return name;
   }
}

package @{genGoloModuleName(type)};\n\n

import io.vertx.lang.golo.InternalHelper;\n\n
@foreach{referencedType : referencedTypes}
import @{referencedType};\n
@end{}

// @{type} \n

public class @{className(type)} { \n\n

private @{type.raw} delegate; \n
@comment{"Next rows defines the constructor"}
public @{className(type.raw)}(Object delegate) { \n
    this.delegate = (@{type.raw})delegate; \n
}\n
public Object getDelegate() { \n
    return delegate; \n
}\n

@declare{'genMethodDispatch'}
	@foreach{method:methods}
// @{method} \n
@code{methodDefinition = createMethodDefinition(type, method)}
public @{methodDefinition} {\n
    @code{
        var cName = className(type.raw);
        callOrgAPI = callForOriginalAPI(cName, type, method);
    }
    @{callOrgAPI}; \n
}\n
@end{}
}\n
@end{}

@includeNamed{'genMethodDispatch';functionNames=new java.util.ArrayList()}