@comment{"Templating! The next row outputs all interfaces annotated with VertxGen-annotation."}
@includeNamed{"common.templ"}

@code{

  def splitHelper(toSplit, splitter) {
    var array = [];
    var start = 0;
    for(int i = 0; i<toSplit.length(); i++) {
        if(toSplit.substring(i, i+1).equals(splitter)) {
            array.add(toSplit.substring(start, i));
            start = i + 1;
        }
    }
    array.add(toSplit.substring(start, toSplit.length()));
    return array;
  }

  def parseGenericNames(genCount, str) {
    var generics = "";
    var identifier = "name=";
    var startIndex = 0;
    for(int i = 0; i<genCount; i++) {
         startIndex = str.indexOf(identifier);
         generics = generics + str.substring(startIndex+identifier.length(),startIndex+identifier.length()+1);
         str = str.substring(startIndex+identifier.length()+1, str.length());
         if(i + 1 < genCount) {
            generics = generics + ",";
         }
     }
    return generics;
  }

  def takeRestOfStr(str, start) {
    var startIndex = str.indexOf(start);
    return str.substring(startIndex, str.length());
  }

  def countGenerics(method) {
    var count = 0;
    for(int i = 0; i<method.toString().length() -12 ; i++) {
            if(method.toString().substring(i, i+13).equals("TypeParamInfo")) {
                count = count + 1;
            }
        }
    return count;
  }

  def injectParamsToMethodDefinition(method) {
    var paramsStr = "(";
    var params = method.params;
    for(param: params) {
        paramsStr = paramsStr + param.type.simpleName + " " + param.name +",";
    }
    if(paramsStr.length() > 1) {
        paramsStr = paramsStr.substring(0, paramsStr.length() - 1);
    }
    return paramsStr + ")";
  }

  def typeCheck(method) {
     var str = method.toString();
     var generics = "";
     var genCount = countGenerics(method);
     var indexOfMethodName = genCount;
     var elementsInMethodDefinition = splitHelper(method.toString(), " ");
     if(genCount == 0) {
        return method.returnType.simpleName + " "+method.name+ injectParamsToMethodDefinition(method);
     }
     generics = parseGenericNames(genCount, method.toString());
     str =  "<"+generics+"> ";
     if(elementsInMethodDefinition[indexOfMethodName] == "void" ||
        generics.contains(elementsInMethodDefinition[indexOfMethodName]) ||
        elementsInMethodDefinition[indexOfMethodName].contains("(") == false) {
        str = str + elementsInMethodDefinition[indexOfMethodName] + " ";
        indexOfMethodName = indexOfMethodName + 1;
     }
     return str + method.name + injectParamsToMethodDefinition(method);
  }

  def genGoloModuleName(type) {
    return type.raw.translatePackageName("golo");
  }

   def className(type) {
        var absName = type.toString();
        var split = splitHelper(absName, ".");
        return split[split.size() - 1];
   }

   def createApiCall(className, type, method) {
        var delegateCall = "";
        if(method.staticMethod) {
            delegateCall = type.raw;
        } else {
            delegateCall = "this.delegate";
        }
        delegateCall = delegateCall + "." + injectParamsToMethodCall(method);
        var currentClass = genGoloModuleName(type.raw) + "." + className + ".class";
        var indexOfClassName = countGenerics(method);
        var castObjectTo = splitHelper(method.toString(), " ")[indexOfClassName];
        var call = "return InternalHelper.safeCreate(" + delegateCall +", "+ genConstructorType(method.returnType.raw) + ".class)";
        return call;
   }

   def handleParam(param) {
    var rStr = "";
    var eventType;
    var eventKind;
    var paramKind = param.type.kind;
    if(paramKind == CLASS_DATA_OBJECT) {
    		rStr = rStr + param.name + " != null ? new " + param.type.name + "(new io.vertx.core.json.JsonObject(" + param.name + ")) : null";
    } else if(param.type.kind.json) {
            rStr = rStr + param.name + " != null ? new " + param.type.name + "(" +param.name + ") : null)";
    } else if(param.type.kind == CLASS_API) {
      		rStr = rStr + "(" + param.type.name + ")" + param.name + ".getDelegate()";
    } else if(param.type.kind == CLASS_OBJECT) {
      		rStr = rStr + "InternalHelper.unwrapObject(" + param.name +")";
    } else if(param.type.kind == CLASS_LIST) {
        var listType = param.type.args[0];
        if(listType.kind == CLASS_API) {
            rStr = rStr + "(List<" + listType.name + ">)(" + param.name + ".collect({underpants -> underpants.getDelegate()}))";
        } else if(listType.kind == CLASS_JSON_OBJECT) {
            rStr = rStr + param.name + ".collect({underpants -> new JsonObject(underpants)})";
        } else if(listType.kind == CLASS_JSON_ARRAY) {
            rStr = rStr + param.name + ".collect({underpants -> new JsonArray(underpants)})";
        } else if(listType.kind == CLASS_DATA_OBJECT) {
            rStr = rStr + param.name + ".collect({underpants -> new " + listType.simpleName + "(new JsonObject(underpants))})";
        }
    } else if(param.type.kind == CLASS_SET) {
        var setType = param.type.args[0];
        if(setType.kind == CLASS_API) {
            rStr = rStr + "(Set<" + setType.name + ">)(" + param.name + ".collect({underpants -> underpants.getDelegate()}) as Set)";
        } else if(setType.kind == CLASS_JSON_OBJECT) {
            rStr = rStr + param.name + ".collect({underpants -> new JsonObject(underpants)}) as Set";
        } else if(setType.kind == CLASS_JSON_ARRAY) {
            rStr = rStr + param.name + ".collect({underpants -> new JsonArray(underpants)}) as Set";
        } else if(setType.kind == CLASS_DATA_OBJECT) {
            rStr = rStr + param.name + ".collect({underpants -> new " + setType.simpleName + "(new JsonObject(underpants))}) as Set";
        }
    } else if(param.type.kind == CLASS_MAP) {
       var mapType = param.type.args[1];
       if(setType.kind == CLASS_API) {
            rStr = rStr + "(Map<String, " + mapType.name + ">)(" + param.name + ".collectEntries({k, v -> [k, v.getDelegate()]}))";
       } else if(setType.kind == CLASS_JSON_OBJECT) {
            rStr = rStr + "(Map<String, " + mapType.name + ">)(" + param.name + ".collectEntries({k, v -> [k, new JsonObject(v)]}))";
       } else if(setType.kind == CLASS_JSON_ARRAY) {
            rStr = rStr + "(Map<String, " + mapType.name + ">)(" + param.name + ".collectEntries({k, v -> [k, new JsonArray(v)]}))";
       }
    } else if(paramKind == CLASS_HANDLER) {
        eventType = param.type.args[0];
        eventKind = eventType.kind;
        if(eventKind == CLASS_OTHER || eventKind.basic || eventKind == CLASS_VOID || eventKind == CLASS_THROWABLE) {
            return param.name;
        } else if(eventKind == CLASS_DATA_OBJECT) {
            return rStr + "new Handler<" + eventType.simpleName + ">() {\n
                    			      public void handle(" + eventType.simpleName + " event) {\n" +
                    			        param.name + ".handle((Map<String, Object>)InternalHelper.wrapObject(event.toJson()));\n
                    			      }\n
                    			    }";
        } else if(eventKind == CLASS_JSON_OBJECT) {
          	return rStr + "new Handler<JsonObject>() {\n
          			      public void handle(JsonObject event) {\n
          			        " + param.name + ".handle((Map<String, Object>)InternalHelper.wrapObject(event));\n
          			      }\n
          			    }";
        } else if(eventKind == CLASS_JSON_ARRAY) {
          	return rStr + "new Handler<JsonArray>() {\n
          			      public void handle(JsonArray event) {\n
          			        " + param.name + ".handle((List<Object>)InternalHelper.wrapObject(event));\n
          			      }\n
          			    }";
        } else if(eventKind == CLASS_LIST || eventKind == CLASS_SET) {
            var elementType = eventType.args[0];
            var elementKind = elementType.kind;
            if(elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING) {
                return rStr + param.name;
            } else if(elementKind == CLASS_API || elementKind.json || elementKind == CLASS_DATA_OBJECT) {
                var collectionName = eventType.raw.simpleName;
                var toGoloElement = "";
                var elementJavaType = "";
                if(elementKind == CLASS_API) {
                    toGoloElement = genConstructor(elementType, "it");
                    elementJavaType = elementType.name;
                } else if(elementKind == CLASS_JSON_OBJECT) {
                    toGoloElement = "InternalHelper.wrapObject(it)";
                    elementJavaType = "JsonObject";
                } else if(elementKind == CLASS_DATA_OBJECT) {
                    toGoloElement = "(Map<String, Object>)InternalHelper.wrapObject(it?.toJson())";
                    elementJavaType = elementType.simpleName;
                } else {
                    toGoloElement = "InternalHelper.wrapObject(it)";
                    elementJavaType = "JsonArray";
                }
                return rStr + "new Handler<" + collectionName +"<" + elementJavaType + ">>() {\n
                      public void handle(" + collectionName + "<" + elementJavaType + "> event) {\n" +
                        param.name + ".handle(event.collect({\n" +
                          toGoloElement + "\n
                        }) as " + collectionName + ")\n
                      }\n
                    }";
            }
        } else if(eventKind == CLASS_API) {
            return rStr + "new Handler<" + eventType.erased.name + ">() {\n
                    			      public void handle(" + eventType.erased.name + " event) {\n" +
                    			        param.name + ".handle(" + genConstructor(eventType.raw, "event") + ");\n
                    			      }\n
                    			    }";
        } else if(eventKind == CLASS_ASYNC_RESULT) {
            var resultType = eventType.args[0];
            var resultKind = resultType.kind;
            if(resultKind == CLASS_OTHER || resultKind.basic || resultKind == CLASS_VOID) {
                return rStr + param.name;
            } else if(resultKind == CLASS_DATA_OBJECT) {
                return rStr + resultHandlerTemplate(resultType.name, "Map<String, Object>", "(Map<String, Object>)InternalHelper.wrapObject(event.result().toJson())", param.name);
            } else if(resultKind == CLASS_LIST || resultKind == CLASS_SET) {
                elementType = resultType.args[0];
                elementKind = elementType.kind;
                if(elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING) {
                    return param.name;
                } else if(elementKind == CLASS_API || elementKind.json || elementKind == CLASS_DATA_OBJECT) {
                    var collectionName = resultType.raw.simpleName;
                    if(elementKind == CLASS_API) {
                        toGoloElement = genConstructor(elementType.raw, "element");
                        elementJavaType = elementType.name;
                        elementGoloType = elementType.simpleName;
                    } else if(elementKind == CLASS_DATA_OBJECT) {
                        toGoloElement = "(Map<String, Object>)InternalHelper.wrapObject(element.toJson())";
                        elementJavaType = elementType.simpleName;
                        elementGoloType = "Map<String, Object>";
                    } else if(elementKind == CLASS_JSON_OBJECT) {
                        toGroovyElement = "InternalHelper.wrapObject(element)";
                        elementJavaType = "JsonObject";
                        elementGroovyType = "Map<String, Object>";
                    } else {
                        toGroovyElement = "InternalHelper.wrapObject(element)";
                        elementJavaType = "JsonArray";
                        elementGroovyType = "List<Object>";
                    }
                    eventJavaType = collectionName + "<" + elementJavaType + ">";
                    eventGoloType = collectionName + "<" + elementGoloType + ">";
                    callbackObject = "event.result().collect({\n            " + elementType.name + " element ->\n            " + toGoloElement + "\n          }) as " + collectionName;
                    return rStr + resultHandlerTemplate(eventJavaType, eventGoloType, callbackObject, param.name);
                }
            } else if(resultKind == CLASS_JSON_OBJECT) {
                return rStr + resultHandlerTemplate(resultType.name ,"Map<String, Object>", "(" + eventGoloType + ")InternalHelper.wrapObject(event.result())",param.name);
            } else if(resultKind == CLASS_JSON_ARRAY) {
                return rStr + resultHandlerTemplate(resultType.name,"List<Object>","(" + eventGoloType + ")InternalHelper.wrapObject(event.result())",param.name);
            } else if(resultKind == CLASS_OBJECT) {
                return rStr + resultHandlerTemplate("Object","Object","InternalHelper.wrapObject(event.result())",param.name);
            } else if(resultKind == CLASS_API) {
                return rStr + resultHandlerTemplate(resultType.name, resultType.simpleName, "new " + resultType.simpleName + "(event.result())", param.name, eventType);
            }
        } else if(eventKind == CLASS_OBJECT) {
            return rStr + "new Handler<Object>() {\n
            			      public void handle(Object event) {\n" +
            			        param.name + ".handle(InternalHelper.wrapObject(event))\n
            			      }\n
            			    }";
        }
    }
    return param.name;
   }

   def injectParamsToMethodCall(method) {
        var call = "";
        call = method.name + "(";
        var params = method.params;
        if(params == empty) {
            return call + ")";
        }
        for(param: params) {
            call = call + handleParam(param) + ",";
        }
        call = call.substring(0, call.length() - 1);
        return call + ")";
   }

   def callForOriginalAPI(className, type, method) {
        if(method.returnType.kind.toString().equals("API")) {
            return createApiCall(className, type, method);
        }
        var call;
        var returnTypes = splitHelper(method.toString(), " ");
        if(returnTypes[0].equals("void") || returnTypes[1].equals("void") ||
            (returnTypes.size() > 2 && returnTypes[2].equals("void"))) {
            call = "";
        } else {
            call = "return ";
        }
        if(method.staticMethod) {
            call = call + type.raw.toString() + ".";
        } else {
            call = call + "this.delegate.";
        }
        call = call + injectParamsToMethodCall(method);
        return call;
   }

   def createMethodDefinition(type, method) {
        var ret = "";
        if(method.staticMethod) {
            ret = "static ";
        }
        return ret + typeCheck(method);
   }

   def resultHandlerTemplate(eventJavaType, eventGoloType, callbackObject, callbackName, eventType) {
    return "new Handler<AsyncResult<" + eventJavaType + ">>() {\n
   	      public void handle(AsyncResult<" + eventJavaType + "> event) {\n
   	        AsyncResult<" + eventGoloType + "> f;\n
   	        if (event.succeeded()) {\n
   	          f = InternalHelper.<" + eventGoloType + ">result(" + callbackObject + ");\n
   	        } else {\n
   	          f = InternalHelper.<" + eventGoloType + ">failure(event.cause());\n
   	        }\n" +
   	        callbackName + ".handle(("+ eventType.simpleName +")f);\n
   	      }\n
   	    }\n";
   }
}

package @{genGoloModuleName(type)};\n\n

import io.vertx.lang.golo.InternalHelper;\n
@comment{"Generate the imports"}
@foreach{importedType:importedTypes}
	@if{importedType.kind == CLASS_API}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.raw.translateName("golo")};\n
		@end{}
	@else{}
		@if{!importedType.packageName.equals("java.lang")}
			import @{importedType};\n
		@end{}
	@end{}
@end{}

// Type: @{type} \n

public class @{className(type)} { \n\n

private @{type.raw} delegate; \n
@comment{"Next rows defines the constructor"}
public @{className(type.raw)}(Object delegate) { \n
    this.delegate = (@{type.raw})delegate; \n
}\n
public Object getDelegate() { \n
    return delegate; \n
}\n

@declare{'genMethodDispatch'}
	@foreach{method:methods}
// @{method} \n
// TypeParams: @{method.typeParams} \n
@code{methodDefinition = createMethodDefinition(type, method)}
public @{methodDefinition} {\n
    @code{
        var cName = className(type.raw);
        callOrgAPI = callForOriginalAPI(cName, type, method);
    }
    //param classes(remove later): @foreach{param:method.params} @code{paramInfo=param.type.kind} @{paramInfo} @end{} \n
    //evenTypes (remove later): @foreach{param:method.params} @if{param.type.kind == CLASS_HANDLER} @code{eventType=param.type.args[0].kind} @{eventType} @end{} @end{} \n
    @{callOrgAPI}; \n
}\n
@end{}
}\n
@end{}

@includeNamed{'genMethodDispatch';functionNames=new java.util.ArrayList()}