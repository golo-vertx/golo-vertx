@comment{"Templating! The next row outputs all interfaces annotated with VertxGen-annotation."}
@includeNamed{"common.templ"}

@code{

  def splitHelper(toSplit, splitter) {
    var array = [];
    var start = 0;
    for(int i = 0; i<toSplit.length(); i++) {
        if(toSplit.substring(i, i+1).equals(splitter)) {
            array.add(toSplit.substring(start, i));
            start = i + 1;
        }
    }
    array.add(toSplit.substring(start, toSplit.length()));
    return array;
  }

  def parseGenericNames(genCount, str) {
    var generics = "";
    var identifier = "name=";
    var startIndex = 0;
    for(int i = 0; i<genCount; i++) {
         startIndex = str.indexOf(identifier);
         generics = generics + str.substring(startIndex+identifier.length(),startIndex+identifier.length()+1);
         str = str.substring(startIndex+identifier.length()+1, str.length());
         if(i + 1 < genCount) {
            generics = generics + ",";
         }
     }
    return generics;
  }

  def takeRestOfStr(str, start) {
    var startIndex = str.indexOf(start);
    return str.substring(startIndex, str.length());
  }

  def countGenerics(method) {
    var count = 0;
    for(int i = 0; i<method.toString().length() -12 ; i++) {
            if(method.toString().substring(i, i+13).equals("TypeParamInfo")) {
                count = count + 1;
            }
        }
    return count;
  }

  def parseClassName(returnValue) {
    var untilIndex = returnValue.indexOf("(");
    var noParams = returnValue.substring(0, untilIndex);
    var methodSplitted = splitHelper(noParams, " ");
    var classPath = methodSplitted[methodSplitted.size() - 2];
    var classSplitted = splitHelper(classPath, ".");
    return classSplitted[classSplitted.size() - 1];
  }

  def injectParamsToMethodDefinition(method) {
    var paramsFrom = method.toString().indexOf("(");
    return method.toString().substring(paramsFrom, method.toString().length());
  }

  def typeCheck(method) {
     var str = method.toString();
     var generics = "";
     var genCount = countGenerics(method);
     var indexOfMethodName = genCount;
     var elementsInMethodDefinition = splitHelper(method.toString(), " ");
     if(genCount == 0) {
        return parseClassName(str) + " "+method.name+ injectParamsToMethodDefinition(method);
     }
     generics = parseGenericNames(genCount, method.toString());
     str =  "<"+generics+"> ";
     if(elementsInMethodDefinition[indexOfMethodName] == "void" ||
        generics.contains(elementsInMethodDefinition[indexOfMethodName]) ||
        elementsInMethodDefinition[indexOfMethodName].contains("(") == false) {
        str = str + elementsInMethodDefinition[indexOfMethodName] + " ";
        indexOfMethodName = indexOfMethodName + 1;
     }
     return str + takeRestOfStr(method.toString(), elementsInMethodDefinition[indexOfMethodName]);
  }

  def genGoloModuleName(type) {
    return type.raw.translatePackageName("golo");
  }

   def className(type) {
        var absName = type.toString();
        var split = splitHelper(absName, ".");
        return split[split.size() - 1];
   }

   def createApiCall(className, type, method) {
        var delegateCall = "";
        if(method.staticMethod) {
            delegateCall = method.returnType.raw;
        } else {
            delegateCall = "this.delegate";
        }
        delegateCall = delegateCall + "." + injectParamsToMethodCall(method);
        var currentClass = genGoloModuleName(type.raw) + "." + className + ".class";
        var indexOfClassName = countGenerics(method);
        var castObjectTo = splitHelper(method.toString(), " ")[indexOfClassName];
        var call = "return InternalHelper.safeCreate(" + delegateCall +", "+ genConstructorType(method.returnType.raw) + ".class)";
        return call;
   }

   def handleParam(param) {
    var eventType;
    var eventKind;
    var paramKind = param.type.kind;
    if(paramKind == CLASS_HANDLER) {
        eventType = param.type.args[0];
        eventKind = eventType.kind;
        if(eventKind == CLASS_OTHER || eventKind.basic || eventKind == CLASS_VOID || eventKind == CLASS_THROWABLE) {
            return param.name;
        } else if(eventKind == CLASS_DATA_OBJECT) {
            return "new Handler<" + eventType.simpleName + ">() {\n
                    			      public void handle(" + eventType.simpleName + " event) {\n" +
                    			        param.name + ".handle((Map<String, Object>)InternalHelper.wrapObject(event.toJson()));\n
                    			      }\n
                    			    }";
        } else if(eventKind == CLASS_JSON_OBJECT) {
          	return "new Handler<JsonObject>() {\n
          			      public void handle(JsonObject event) {\n
          			        " + param.name + ".handle((Map<String, Object>)InternalHelper.wrapObject(event));\n
          			      }\n
          			    }";
        } else if(eventKind == CLASS_JSON_ARRAY) {
          	return "new Handler<JsonArray>() {\n
          			      public void handle(JsonArray event) {\n
          			        " + param.name + ".handle((List<Object>)InternalHelper.wrapObject(event));\n
          			      }\n
          			    }";
        } else if(eventKind == CLASS_LIST || eventKind == CLASS_SET) {
            var elementType = eventType.args[0];
            var elementKind = elementType.kind;
            if(elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING) {
                return param.name;
            } else if(elementKind == CLASS_API || elementKind.json || elementKind == CLASS_DATA_OBJECT) {
                var collectionName = eventType.raw.simpleName;
                var toGoloElement = "";
                var elementJavaType = "";
                if(elementKind == CLASS_API) {
                    toGoloElement = genConstructor(elementType, "it");
                    elementJavaType = elementType.name;
                } else if(elementKind == CLASS_JSON_OBJECT) {
                    toGoloElement = "InternalHelper.wrapObject(it)";
                    elementJavaType = "JsonObject";
                } else if(elementKind == CLASS_DATA_OBJECT) {
                    toGoloElement = "(Map<String, Object>)InternalHelper.wrapObject(it?.toJson())";
                    elementJavaType = elementType.simpleName;
                } else {
                    toGoloElement = "InternalHelper.wrapObject(it)";
                    elementJavaType = "JsonArray";
                }
                return "new Handler<" + collectionName +"<" + elementJavaType + ">>() {\n
                      public void handle(" + collectionName + "<" + elementJavaType + "> event) {\n" +
                        param.name + ".handle(event.collect({\n" +
                          toGoloElement + "\n
                        }) as " + collectionName + ")\n
                      }\n
                    }";
            }
        } else if(eventKind == CLASS_API) {
            return "new Handler<" + eventType.erased.name + ">() {\n
                    			      public void handle(" + eventType.erased.name + " event) {\n" +
                    			        param.name + ".handle(" + genConstructor(eventType.raw, "event") + ");\n
                    			      }\n
                    			    }";
        } else if(eventKind == CLASS_ASYNC_RESULT) {
            var resultType = eventType.args[0];
            var resultKind = resultType.kind;
            if(resultKind == CLASS_OTHER || resultKind.basic || resultKind == CLASS_VOID) {
                return param.name;
            } else if(resultKind == CLASS_DATA_OBJECT) {
                return resultHandlerTemplate(resultType.name, "Map<String, Object>", "(Map<String, Object>)InternalHelper.wrapObject(event.result().toJson())", param.name);
            } else if(resultKind == CLASS_LIST || resultKind == CLASS_SET) {
                elementType = resultType.args[0];
                elementKind = elementType.kind;
                if(elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING) {
                    return param.name;
                } else if(elementKind == CLASS_API || elementKind.json || elementKind == CLASS_DATA_OBJECT) {
                    var collectionName = resultType.raw.simpleName;
                    if(elementKind == CLASS_API) {
                        toGoloElement = genConstructor(elementType.raw, "element");
                        elementJavaType = elementType.name;
                        elementGoloType = elementType.simpleName;
                    } else if(elementKind == CLASS_DATA_OBJECT) {
                        toGoloElement = "(Map<String, Object>)InternalHelper.wrapObject(element.toJson())";
                        elementJavaType = elementType.simpleName;
                        elementGoloType = "Map<String, Object>";
                    } else if(elementKind == CLASS_JSON_OBJECT) {
                        toGroovyElement = "InternalHelper.wrapObject(element)";
                        elementJavaType = "JsonObject";
                        elementGroovyType = "Map<String, Object>";
                    } else {
                        toGroovyElement = "InternalHelper.wrapObject(element)";
                        elementJavaType = "JsonArray";
                        elementGroovyType = "List<Object>";
                    }
                    eventJavaType = collectionName + "<" + elementJavaType + ">";
                    eventGoloType = collectionName + "<" + elementGoloType + ">";
                    callbackObject = "event.result().collect({\n            " + elementType.name + " element ->\n            " + toGoloElement + "\n          }) as " + collectionName;
                    return resultHandlerTemplate(eventJavaType, eventGoloType, callbackObject, param.name);
                }
            } else if(resultKind == CLASS_JSON_OBJECT) {
                return resultHandlerTemplate(resultType.name ,"Map<String, Object>", "(" + eventGoloType + ")InternalHelper.wrapObject(event.result())",param.name);
            } else if(resultKind == CLASS_JSON_ARRAY) {
                return resultHandlerTemplate(resultType.name,"List<Object>","(" + eventGoloType + ")InternalHelper.wrapObject(event.result())",param.name);
            } else if(resultKind == CLASS_OBJECT) {
                return resultHandlerTemplate("Object","Object","InternalHelper.wrapObject(event.result())",param.name);
            }
        }
    }
    return param.name;
   }

   def injectParamsToMethodCall(method) {
        var call = "";
        call = method.name + "(";
        var params = method.params;
        if(params == empty) {
            return call + ")";
        }
        for(param: params) {
            call = call + handleParam(param) + ",";
        }
        call = call.substring(0, call.length() - 1);
        return call + ")";
   }

   def isConstructorMethod(type, method) {
        if(method.staticMethod) {
            var cp = splitHelper(method.toString(), " ");
            var classIndex = countGenerics(method);
            var class = cp[classIndex];
            if(class.equals(type.toString())) {
                return true;
            }
        }
        return false;
   }

   def callForOriginalAPI(className, type, method) {
        if(method.returnType.kind.toString().equals("API")) {
            return createApiCall(className, type, method);
        }
        var call;
        var returnTypes = splitHelper(method.toString(), " ");
        if(returnTypes[0].equals("void") || returnTypes[1].equals("void") ||
            (returnTypes.size() > 2 && returnTypes[2].equals("void"))) {
            call = "";
        } else {
            call = "return ";
        }
        if(method.staticMethod) {
            call = call + type.raw.toString() + ".";
        } else {
            call = call + "delegate.";
        }
        call = call + injectParamsToMethodCall(method);
        return call;
   }

   def createMethodDefinition(type, method) {
        var ret = "";
        if(method.staticMethod) {
            ret = "static ";
        }
        return ret + typeCheck(method);
   }

   def resultHandlerTemplate(eventJavaType, eventGoloType, callbackObject, callbackName) {
    return "new Handler<AsyncResult<" + eventJavaType + ">>() {\n
   	      public void handle(AsyncResult<" + eventJavaType + "> event) {\n
   	        AsyncResult<" + eventGoloType + "> f;\n
   	        if (event.succeeded()) {\n
   	          f = InternalHelper.<" + eventGoloType + ">result(" + callbackObject + ");\n
   	        } else {\n
   	          f = InternalHelper.<" + eventGoloType + ">failure(event.cause());\n
   	        }\n" +
   	        callbackName + ".handle(f);\n
   	      }\n
   	    }";
   }
}

package @{genGoloModuleName(type)};\n\n

import io.vertx.lang.golo.InternalHelper;\n\n
@foreach{referencedType : referencedTypes}
import @{referencedType};\n
@end{}

// @{type} \n

public class @{className(type)} { \n\n

private @{type.raw} delegate; \n
@comment{"Next rows defines the constructor"}
public @{className(type.raw)}(Object delegate) { \n
    this.delegate = (@{type.raw})delegate; \n
}\n
public Object getDelegate() { \n
    return delegate; \n
}\n

@declare{'genMethodDispatch'}
	@foreach{method:methods}
// @{method} \n
@code{methodDefinition = createMethodDefinition(type, method)}
public @{methodDefinition} {\n
    @code{
        var cName = className(type.raw);
        callOrgAPI = callForOriginalAPI(cName, type, method);
    }
    @{callOrgAPI}; \n
}\n
@end{}
}\n
@end{}

@includeNamed{'genMethodDispatch';functionNames=new java.util.ArrayList()}