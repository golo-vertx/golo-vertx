@comment{"Templating! The next row outputs all interfaces annotated with VertxGen-annotation."}

@code{

  def splitHelper(toSplit, splitter) {
    var array = [];
    var start = 0;
    for(int i = 0; i<toSplit.length(); i++) {
        if(toSplit.substring(i, i+1).equals(splitter)) {
            array.add(toSplit.substring(start, i));
            start = i + 1;
        }
    }
    array.add(toSplit.substring(start, toSplit.length()));
    return array;
  }

  def genGoloModuleName(type) {
    var body = type.raw.translatePackageName("golo");
    for (int i = body.length()-2; i >= 0 ; i--) {
               if(body.substring(i, i+1).equals(".")) {
                     return body.substring(0,i+1) + body.substring(i+1,i+2).toUpperCase() + body.substring(i+2);
               }
     }
    return body;
    }

   def className(type) {
        var absName = type.raw.toString();
        var split = splitHelper(absName, ".");
        return split[split.size() - 1];
   }

   def callForOriginalAPI(method) {
        var call = "originalInstance."  + method.name + "(";
        var params = method.params;
        var p;
        for(int i = 0; i < params.size(); i++) {
            p = splitHelper(params.get(i).name, " ");
            call = call + p[0];
            if(i < params.size() - 1) {
                call = call + ", ";
            }
        }
        return call + ")";
   }

   def findUniqueFunctionName(functionNames, method) {
        if(method.params == empty) {
            functionNames.add(method.name);
            return method.name;
        }
        var nameIsFree = true;
        var currentName = "";
        for(int y=0; y < functionNames.size(); y++) {
            currentName = functionNames.get(y);
            if(currentName == method.name) {
                nameIsFree = false;
            }
        }
        if(nameIsFree) {
            functionNames.add(method.name);
            return method.name;
        }
        var name = method.name + "By";
        var mini = "";
        for (int i =0; i < method.params.size(); i++) {
           mini = method.params.get(i).name;
           name += mini.substring(0,1).toUpperCase() + mini.substring(1,mini.length());
           if(i != method.params.size() -1) {
                name += "And";
           }
        }
        return name;
   }
}

package @{genGoloModuleName(type)};\n\n

@foreach{referencedType : referencedTypes}
import @{referencedType};\n
@end{}


@code{className = className(type)}
public class @{className} { \n\n

private @{type} originalInstance; \n

@declare{'genMethodDispatch'}
	@foreach{method:methods}
// @{method} \n
public @{method} {\n
    @code{callOrgAPI = callForOriginalAPI(method)}
    return @{callOrgAPI}; \n
}\n
@end{}
}\n
@end{}

@includeNamed{'genMethodDispatch';functionNames=new java.util.ArrayList()}